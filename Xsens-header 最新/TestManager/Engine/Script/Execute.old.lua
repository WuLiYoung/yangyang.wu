--system callback, just only call once when application startup--local variablelocal state=0;function __app_startup(arg)endfunction __app_finish(arg)endlocal PASS=1;local FAIL=0;local ERROR=-1;local SKIPPED=2;local EN_DEBUG = 0;function Entry(fun,...)		--Log Function	if (EN_DEBUG == 0) then return; end	str = tostring(fun);	if(...) then		for i,v in ipairs{...}do			str=str.." "..tostring(v);		end	end	DbgOut(str);endfunction TestFlowOut(str)endfunction CheckResult(lower,upper,value)				--根据spec检验测试结果，PASS:在spec之内 FAIL:在spec范围之外	TestFlowOut("lower:%s upper:%s value:%s",tostring(lower),tostring(upper),tostring(value));--	if (not value) then do return PASS end end;		--value 为nil	local res=PASS;		--all pass	if (lower) or (upper) then		if (type(lower)=="number") or (type(upper)=="number") then			--spec为数字类型			--assert(type(value)=="number","Returen value with incorrect format,expect number ,reutrn format is "..type(value));						--根据spec强制转换结果，避免产生错误			value=tonumber(value);			if (not value) then return FAIL end;			if (lower) then				if (value<lower) then					res = FAIL;				end			end			if (upper) then				if (value>upper) then					res = FAIL;				end			end		elseif (type(lower)=="string") or (type(upper)=="string")  then		--spec为字符串类型			--assert(type(value)=="string","Returen value with incorrect format,expect string ,reutrn format is "..type(value));			if (not value) then				return FAIL; 			end	--返回为nil			value=tostring(value);			if (#(tostring(lower))==0) and (#(tostring(upper))==0) then 				return PASS; 			end	--spec为空字符串，匹配任意字符			if (tostring(value)==lower) then 				return PASS;			else				return FAIL;			end		end	else							--没有设定spec,处理成P/F值		if (tonumber(value)==0) or (value == nil) then	--返回0或没有返回值，当作PASS处理			res = PASS;		else			res = FAIL;		end	end	return res;endlocal __result=PASS;this={};				--当前测试项目--执行一个测试Itemlocal steps=-1;local function Excute_Item(item)		Entry("Entry \""..item.name.."\" Item");		--Log message		this=item;		local value=0;		local state=0;		if (type(item.entry)=="function") then		--Do test function			Entry("Call "..tostring(item.entry));			if (item.parameter==nil) then item.parameter = {} end;			value,display =item.entry(item.parameter);--			value=0;	--just for debug						--判定测试结果		--			DbgOut("value1 : %s value2 : %s value3 : %s value4 : %s",tostring(value1),tostring(value2),tostring(value3),tostring(value4)); 			state = CheckResult(item.lower,item.upper,value);						if (item.lower == nil) and (item.upper==nil) then		--无值型测试项，一般用于执行一个动作				if (tonumber(value)==0) or (value == nil) then	--返回0或没有返回值，当作PASS处理					value="PASS"					state=1;				else 					value="FAIL" 					state=0;				end			end						if (state>0) then				TestFlowOut("\tPASS");			else				TestFlowOut("\tFAIL");			end		elseif(type(item.entry) == "string") then		--为字符串形式，直接执行该字符串			DbgOut("value.entry : %s",tostring(item.entry));			local func,err = loadstring(item.entry);			assert(func~=nil,tostring(err));			--exception			value = func();						--判定测试结果		--			DbgOut("value1 : %s value2 : %s value3 : %s value4 : %s",tostring(value1),tostring(value2),tostring(value3),tostring(value4)); 			state = CheckResult(item.lower,item.upper,value);			if (item.lower == nil) then		--无值型测试项				if (tonumber(value)==0) then					value="PASS" 					state=1;				else 					value="FAIL" 					state=0;				end			end						if (state>0) then				TestFlowOut("\tPASS");			else				TestFlowOut("\tFAIL");			end		else	--其他任意格式，不执行处理			display="Skipped"			value="Skipped";--			item_state=0x0F;			state=2;		end				Entry("Leave \""..item.name.."\" Item\r\n");		TestFlowOut("");			return value, state,display;end--test sequencefunction __Engine_Initial(arg)endfunction __Engine_Finish(arg)endfunction __initial_test(arg)	ui.TEST_START();		--Update UI to start testendfunction __finish_test(arg)		ui.TEST_FINISH(state);			--Show test ressultendlocal index=0;function __Execute_Item(it)	local ret=0;	local state=0;	local display=nil;		ui.ITEM_START();		--Update UI of current item	for v in pairs(it) do		Log("it["..v.."] : "..tostring(it[v]).."\r\n");	end	ret,state,display=Excute_Item(it);	--return format:--b,v,	ui.ITEM_FINISH(ret,state,display);		--Update UIend